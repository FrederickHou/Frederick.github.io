---
layout:     post
title:      死锁介绍
subtitle:   死锁四个必要条件及死锁的预防、检测、避免、解除
date:       2020-04-09
author:     Frederick
header-img: img/post-bg-os-metro.jpg
categories:
    - 技术笔记
    - 操作系统
tags:
    - 效率
    - 操作系统
toc: true
---

# 什么是死锁？

当我们第一次加锁以后，再次进行加锁，这样会发生什么？
当我们第二次申请锁的时候，这个时候锁已经被占用了，该线程就会被挂起，但是刚好这个线程就是拥有锁的线程了，那么这个线程就永远挂起等待了，这个我们就叫 **死锁** 。

## 死锁产生的原因

- **1** 一个线程两次申请锁。

- **2** 两个线程互相申请对方的锁，但是对方都不释放锁。

## 死锁产生的必要条件

- **互斥：** 一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。

- **占有且等待** ：当一个进程在等待分配得到其他资源时，其继续占有已分配得到的资源。

- **非抢占：** 不能强行抢占进程中已占有的资源。

- **循环等待：** 存在一个封闭的进程链，使得每个资源至少占有此链中下一个进程所需要的一个资源。

## 处理死锁的方法

- **死锁预防：** 通过确保死锁的一个必要条件不会满足，保证不会发生死锁。

- **死锁检测：** 允许死锁的发生，但是可以通过系统设置的检测结构及时的检测出死锁的发生，采取一些措施，将死锁清除掉。

- **死锁避免：** 在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁。

- **死锁解除：** 与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。

**常用方法：** 撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。

## 死锁避免算法：

### 银行家算法：

- **1.** 如果request<=need，转向步骤2；否则认为出错，因为请求资源大于需要资源。

- **2.** 如果request<=available，转向步骤3,；否则尚无足够资源，进程p阻塞。

- **3.** 系统尝试为把资源分配给进程P，并修改available、allocation和need的数值。

- **4.** 系统执行安全性算法，检查此次分配后系统是否处于 **安全状态** ，若安全，才正式将资源分配给进程P，否则将本次试探性分配作废，让进程P等待。

**安全状态：** 系统能按照某种进程顺序，为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成。


