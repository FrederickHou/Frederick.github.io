---
layout:     post
title:      Redis(一)之入门详解
subtitle:   Redis基础知识介绍。
date:       2019-04-28
author:     Frederick
header-img: img/redis.jpeg
catalog: true
tags:
    - Redis
---

## Redis简介：

Redis是一款开源的、高性能的键-值存储（key-value store）。它常被称作是一款数据结构服务器（data structure server）。

Redis的键值可以包括字符串（strings）类型，同时它还包括哈希（hashes）、列表（lists）、集合（sets）和 有序集合（sorted sets）等数据类型。 对于这些数据类型，你可以执行原子操作。例如：对字符串进行附加操作（append）；递增哈希中的值；向列表中增加元素；计算集合的交集、并集与差集等。

为了获得优异的性能，Redis采用了内存中（in-memory）数据集（dataset）的方式。同时，Redis支持数据的持久化，你可以每隔一段时间将数据集转存到磁盘上（snapshot），或者在日志尾部追加每一条操作命令（append only file,aof）。

Redis同样支持主从复制（master-slave replication），并且具有非常快速的非阻塞首次同步（ non-blocking first synchronization）、网络断开自动重连等功能。同时Redis还具有其它一些特性，其中包括简单的事物支持、发布订阅 （ pub/sub）、管道（pipeline）和虚拟内存（vm）等 。
Redis具有丰富的客户端，支持现阶段流行的大多数编程语言

## Redis安装：
下载最新稳定版 redis（ http://redis.io/download )
tar zxvf redis-5.0.4.tar.gz 解压后的目录如下：
```
ls
00-RELEASENOTES  COPYING  Makefile   redis.conf       runtest-sentinel  tests
BUGS             deps     MANIFESTO  runtest          sentinel.conf     utils
CONTRIBUTING     INSTALL  README.md  runtest-cluster  src

```
cd src 进入src目录
make 编译Redis
make test 可以测试一下，最终成功测试结果如下。
```
\o/ All tests passed without errors!
```
make install 安装
```
Hint: It's a good idea to run 'make test' ;)

    INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
    INSTALL install
```
**启动Redis服务端如下**(默认端口号6379)：
此时redis已经运行，但要获得好的性能和符合项目特点，还需要对配置文件进行合理的配置,对/etc/redis/redis.conf文件进行修改即可。
```
redis-server 
16923:C 27 Apr 21:57:47.289 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf
16923:M 27 Apr 21:57:47.290 * Increased maximum number of open files to 10032 (it was originally set to 1024).
                _._                                                  
           _.-``__ ''-._                                             
      _.-``    `.  `_.  ''-._           Redis 3.0.6 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._                                   
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 16923
  `-._    `-._  `-./  _.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |           http://redis.io        
  `-._    `-._`-.__.-'_.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |                                  
  `-._    `-._`-.__.-'_.-'    _.-'                                   
      `-._    `-.__.-'    _.-'                                       
          `-._        _.-'                                           
              `-.__.-'                                               
```
**连接客户端如下**
```
redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379> 
```
## Redis的数据类型：
**Keys**  非二进制安全的字符类型（ not binary-safe strings ）
**Values** Strings Lists Sets Sorted sets Hash

**String类型**：
string是redis最基本的类型，而且string类型是二进制安全的。
redis的string可以包含任何数据。包括jpg图片或者序列化的对象。
最大上限是1G字节。 
如果只用string类型，redis就可以被看作加上持久化特性的memcached

**String相关命令**：
**set** key value 设置key对应的值为string类型的value,返回1表示成功，0失败
**setnx** key value 同上，如果key已经存在，返回0 。nx 是not exist的意思
**get** key 获取key对应的string值,如果key不存在返回nil
**getset** key value 设置key的值，并返回key的旧值。如果key不存在返回nil
**mget** key1 key2 ... keyN 一次获取多个key的值，如果对应key不存在，则对应返回nil。下面是个实验, nonexisting不存在，对应返回nil
```
127.0.0.1:6379> set newKey abd
OK
127.0.0.1:6379> setnx newKey abd
(integer) 0
127.0.0.1:6379> get newKey
"abd"
127.0.0.1:6379> mget myKey newKey otherkey
1) "abc"
2) "abd"
3) (nil)
```

**List类型：**
redis的list类型其实就是一个每个子元素都是string类型的双向链表。我们可以通过push,pop操作从链表的头部或者尾部添加删除元素。这使得list既可以用作栈，也可以用作队列。
list的pop操作还有阻塞版本的。当我们[lr]pop一个list对象时，如果list是空，或者不存在，会立即返回nil。但是阻塞版本的b[lr]pop则可以阻塞，当然可以加超时时间，超时后也会返回nil。为什么要阻塞版本的pop呢，主要是为了避免轮询。举个简单的例子如果我们用list来实现一个工作队列。执行任务的thread可以调用阻塞版本的pop去获取任务这样就可以避免轮询去检查是否有任务存在。当任务来时候工作线程可以立即返回，也可以避免轮询带来的延迟。

**List的相关命令：**
**lpush** key string 在key对应list的头部添加字符串元素，返回1表示成功，0表示key存在且不是list类型。
**rpush** key string 同上，在尾部添加。
**llen** key 返回key对应list的长度，key不存在返回0,如果key对应类型不是list返回错误。
**lrange** key start end 返回指定区间内的元素，下标从0开始，负值表示从后面计算，-1表示倒数第一个元素 ，key不存在返回空列表。
**ltrim** key start end  截取list，保留指定区间内元素，成功返回1，key不存在返回错误。
**lset** key index value 设置list中指定下标的元素值，成功返回1，key或者下标不存在返回错误。
**lrem** key count value 从key对应list中删除count个和value相同的元素。count为0时候删除全部。
**lpop** key 从list的头部删除元素，并返回删除元素。如果key对应list不存在或者是空返回nil，如果key对应值不是list返回错误。
**rpop** 同上，但是从尾部删除。
**blpop** key1...keyN timeout 从左到右扫描返回对第一个非空list进行lpop操作并返回，比如blpop list1 list2 list3 0 ,如果list不存在，list2,list3都是非空则对list2做lpop并返回从list2中删除的元素。如果所有的list都是空或不存在，则会阻塞timeout秒，timeout为0表示一直阻塞。当阻塞时，如果有client对key1...keyN中的任意key进行push操作，则第一在这个key上被阻塞的client会立即返回。如果超时发生，则返回nil。
**brpop** 同blpop，一个是从头部删除一个是从尾部删除。
**rpoplpush** srckey destkey 从srckey对应list的尾部移除元素并添加到destkey对应list的头部,最后返回被移除的元素值，整个操作是原子的.如果srckey是空或者不存在返回nil。
```
127.0.0.1:6379> lpush myList a
(integer) 1
127.0.0.1:6379> llen myList
(integer) 1
127.0.0.1:6379> lrange myList 0 -1
1) "b"
2) "a"
127.0.0.1:6379> ltrim myList 0 1
OK
127.0.0.1:6379> lset myList 0 www
OK
127.0.0.1:6379> lrem myList 3 b
(integer) 3
```
**Set类型：**
redis的set是string类型的无序集合。
set元素最大可以包含(2的32次方-1)个元素。
set的是通过hash table实现的，hash table会随着添加或者删除自动的调整大小
关于set集合类型除了基本的添加删除操作，其他有用的操作还包含集合的取并集(union)，交集(intersection)，差集(difference)。通过这些操作可以很容易的实现sns中的好友推荐和blog的tag功能。

**Set的相关命令：**
**sadd** key member 添加一个string元素到,key对应的set集合中，成功返回1,如果元素以及在集合中返回0,key对应的set不存在返回错误
**srem** key member 从key对应set中移除给定元素，成功返回1，如果member在集合中不存在或者key不存在返回0，如果key对应的不是set类型的值返回错误
**spop** key 删除并返回key对应set中随机的一个元素,如果set是空或者key不存在返回nil
**srandmember** key 同spop，随机取set中的一个元素，但是不删除元素
**smove** srckey dstkey member 从srckey对应set中移除member并添加到dstkey对应set中，整个操作是原子的。成功返回1,如果member在srckey中不存在返回0，如果key不是set类型返回错误
**scard** key 返回set的元素个数，如果set是空或者key不存在返回0
**sismember** key member 判断member是否在set中，存在返回1，0表示不存在或者key不存在
**sinter** key1 key2...keyN 返回所有给定key的交集
**sinterstore** dstkey key1...keyN 同sinter，但是会同时将交集存到dstkey下
**sunion** key1 key2...keyN 返回所有给定key的并集
**sunionstore** dstkey key1...keyN 同sunion，并同时保存并集到dstkey下
**sdiff** key1 key2...keyN 返回所有给定key的差集
**sdiffstore** dstkey key1...keyN 同sdiff，并同时保存差集到dstkey下
**smembers** key 返回key对应set的所有元素，结果是无序的
```
127.0.0.1:6379> sadd newKey hello
(integer) 1
127.0.0.1:6379> sadd newKey work
(integer) 1
127.0.0.1:6379> sadd newKey word
(integer) 1
127.0.0.1:6379> spop newKey
"work"
127.0.0.1:6379> srandmember newKey
"hello"
127.0.0.1:6379> sadd myKey hello
(integer) 1
127.0.0.1:6379> smove newKey myKey word
(integer) 1
127.0.0.1:6379> scard newKey
(integer) 1
127.0.0.1:6379> scard myKey
(integer) 2
127.0.0.1:6379> sismember myKey hello 
(integer) 1
127.0.0.1:6379> sinter newKey myKey
1) "hello"
127.0.0.1:6379> sunion newKey myKey
1) "hello"
2) "word"
127.0.0.1:6379> sunionstore dstkey newKey myKey
(integer) 2
127.0.0.1:6379> sdiff newKey myKey
(empty list or set)
```
**Sorted Set类型：**
和set一样sorted set也是string类型元素的集合，不同的是每个元素都会关联一个double类型的score。sorted set的实现是skip list和hash table的混合体。当元素被添加到集合中时，一个元素到score的映射被添加到hash table中，另一个score到元素的映射被添加到skip list并按照score排序，所以就可以有序的获取集合中的元素。

**Sorted Set的相关命令：**
**zadd** key score member 添加元素到集合，元素在集合中存在则更新对应score
**zrem** key member 删除指定元素，1表示成功，如果元素不存在返回0
**zincrby** key incr member 增加对应member的score值，然后移动元素并保持skip list有序。返回更新后的score值
**zrank** key member 返回指定元素在集合中的排名（下标，非score）,集合中元素是按score从小到大排序的
**zrevrank** key member 同上,但是集合中元素是按score从大到小排序
**zrange** key start end 类似lrange操作从集合中取指定区间的元素。返回的是有序结果
**zrevrange** key start end 同上，返回结果是按score逆序的
**zrangebyscore** key min max 返回集合中score在给定区间的元素
**zcount** key min max 返回集合中score在给定区间的数量
**zcard** key 返回集合中元素个数
**zscore** key element  返回给定元素对应的score
**zremrangebyrank** key min max 删除集合中排名在给定区间的元素
**zremrangebyscore** key min max 删除集合中score在给定区间的元素

**Hash类型：**
redis hash是一个string类型的field和value的映射表。
hash特别适合用于存储对象。相较于将对象的每个字段存成单个string类型。将一个对象存储在hash类型中会占用更少的内存，并且可以更方便的存取整个对象。

**Hash的相关命令：**
**hset** key field value 设置hash field为指定值，如果key不存在，则先创建
**hget** key field  获取指定的hash field
**hmget** key filed1....fieldN 获取全部指定的hash filed
**hmset** key filed1 value1 ... filedN valueN 同时设置hash的多个field
**hincrby** key field integer

###key的相关命令
**set** key value 设置一个新的数据，如果key不存在则创建，如果存在则更新key对应value的值。
**GET** key 获取key对应value的值，如果存在则返回，不存在返回nil。
**exits** key 测试指定key是否存在，返回1表示存在，0不存在。
**del** key1 key2 ....keyN  删除给定key,返回删除key的数目，0表示给定key都不存在。
**type** key 返回给定key的value类型。返回 none 表示不存在，key有string字符类型，list 链表类型 set
无序集合类型等...
**keys** pattern 返回匹配指定模式的所有key（支持*，？，[abc ])的方式。
**RANDOMKEY** 返回从当前数据库中随机选择的一个key,如果当前数据库是空的，返回空串 
**RENAME** oldkey newkey 原子的重命名一个key,如果newkey存在，将会被覆盖，返回1表示成功，0失败。失败可能是oldkey不存在或者和newkey相同
**RENAMENX** oldkey newkey 同上，但是如果newkey存在返回失败
**DBSIZE** 返回当前数据库的key数量
**EXPIRE** key seconds 为key指定过期时间，单位是秒。返回1成功，0表示key已经设置过过期时间或者不存在
**ttl** key 返回设置了过期时间的key的剩余过期秒数， -2表示key不存在或者没有设置过过期时间
**SELECT** db-index 通过索引选择数据库，默认连接的数据库索引是0,默认数据库数是16个。返回1表示成功，0失败
**MOVE** key db-index  将key从当前数据库移动到指定数据库。返回1成功。0 如果key不存在，或者已经在指定数据库中
**FLUSHDB** 删除当前数据库中所有key,此方法不会失败。慎用
**FLUSHALL** 删除所有数据库中的所有key，此方法不会失败。更加慎用

**示例如下：**
```
127.0.0.1:6379> set newKey abc
OK
127.0.0.1:6379> EXISTS newKey
(integer) 1
127.0.0.1:6379> type newKey
string
127.0.0.1:6379> KEYS new*
1) "newKey"
127.0.0.1:6379> del newKey
(integer) 1
127.0.0.1:6379> RANDOMKEY
(nil)
127.0.0.1:6379> RENAME newKey myKey
OK
127.0.0.1:6379> DBSIZE
(integer) 1
127.0.0.1:6379> EXPIRE myKey 10
(integer) 1
127.0.0.1:6379> ttl myKey
(integer) 5
127.0.0.1:6379> FLUSHDB
OK
127.0.0.1:6379> FLUSHALL
OK
```