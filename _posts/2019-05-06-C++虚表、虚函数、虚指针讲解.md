---
layout:     post
title:      C++ 虚函数表、虚函数讲解
subtitle:   C++ 虚函数表、虚函数指针和虚函数原理。
date:       2019-05-07
author:     Frederick
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - C++
---
# 前言

近期有不少同学私信我询问关于C++ 虚表和虚函数的相关问题，于是就打算写一篇关于C++虚函数和虚表的原理文章有助于大家更好的去理解和学习。

***

# 虚函数

### 概念

虚函数是一种在基类中用virtual关键字声明的函数，并在一个或多个派生类中再定义的函数。虚函数的特点是，只要定义一个基类的指针，就可以指向派生类的对象。

**[注：无虚函数时，遵循以下规则：C++规定，定义为基类的指针，也能作指向派生类的指针使用，并可以用这个指向派生类对象的指针访问继承来的基类成员；但不能用它访问派生类的成员。]**

- 使用虚函数实现运行时的多态性的关键在于：必须通过基类指针访问这些函数。

- 一旦一个函数定义为虚函数，无论它传下去多少层，一直保持为虚函数。

- 把虚函数的再定义称为过载（overriding）而不叫重载（overloading）。

- 纯虚函数：是定义在基类中的一种只给出函数原型，而没有任何与该基类有关的定义的函数。纯虚函数使得任何派生类都必须定义自己的函数版本。否则编译报错。纯虚函数定义的一般形式：
 ```
   virtual type func_name(args)=0;
 ```
- 含有纯虚函数的基类称为抽象基类。抽象基类又一个重要特性：抽象类不能建立对象。但是抽象基类可以有指向自己的指针，以支持运行时的多态性。

**虚函数示例代码**

```
#include"test.h"
#include<iostream>
using namespace std;

class Base{

public:

    void printf()
    {
        cout << "Base printf()" << endl;
    }

    virtual void func()
    {
        cout << "Base func()" << endl;
    }

};

class Derived:public Base{

public:

    void printf()
    {
        cout << "Derived printf()" << endl;
    }

    virtual void func()
    {
        cout << "Derived func()" << endl;
    }

};
```
**示例讲解**

在以上示例代码中，我们声明了一个父类 Base，和它的一个派生类 Derive，其中 printf() 实例方法是非虚函数，而func()方法被声明为了虚函数。并且在子类中我们重新实现了printf() 和 func()方法。下面我们分别构造出一个 Derive 实例和Base 实例，分别用示例对象访问各func()和printf()方法。然后构造新的Derived实例，并分别将其地址赋给 Base 指针和 Derived 指针，然后分别输出访问func()和printf()方法的结果：


```
int main()
{
    Base baseObj = Base();
    baseObj.func();
    baseObj.printf();
    Derived derivedObj = Derived();
    derivedObj.func();
    derivedObj.printf();

    Derived* pDerivedObj = new Derived();
    Base* pBaseObj = pDerivedObj;
    pDerivedObj->func();
    pBaseObj->func();
    pDerivedObj->printf();
    pBaseObj->printf();
    delete pDerivedObj;
    return 0;
}
```


**运行结果**
```
Terminal output result:

Base func()
Base printf()
Derived func()
Derived printf()

Derived func()
Derived func()
Derived printf()
Base printf()
```

**结果描述**

Base和Derived实例分别访问func()和printf()方法。运行结果为各自对应的func()和printf()方法输出。
pDerivedObj 和 pBaseObj指针分别指向了Derived实例的地址，对于 pDerivedObj 指针的操作表现出来它本身的方法输出，然而当我们把相同对象的地址赋给 pBaseObj 指针时，可以发现它的非虚函数printf()竟然表现出了父类的行为，并没有被重写的样子。那到底是什么原因造成了这样的结果呢？我们继续往下看虚函数表的介绍。

# 虚函数表

虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。



# 虚函数指针

## 未完待续......

**博客著作权归本作者所有，任何形式的转载都请联系作者获得授权并注明出处。**